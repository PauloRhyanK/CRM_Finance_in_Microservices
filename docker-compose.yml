services:
  # --- API GATEWAY (A ENTRADA PRINCIPAL) ---
  api-gateway:
    build:
      context: ./gateway
    container_name: api_gateway
    restart: unless-stopped
    ports:
      - "8080:8080"
    env_file: .env
    environment:
      - AUTH_SERVICE_URL=http://auth-service:5000
      - CUSTOMER_SERVICE_URL=http://customer-service:5000
      - PRODUCT_SERVICE_URL=http://product-service:5000
      - INTERACTION_SERVICE_URL=http://interaction-service:5000
    depends_on:
      - auth-service
      - customer-service
      - product-service
      - interaction-service
    volumes:
    - ./gateway:/app
    networks:
      - crm_network

  # --- SERVIÇO DE AUTENTICAÇÃO ---
  auth-service:
    build:
      context: ./services/auth-service
    container_name: auth_service
    restart: unless-stopped
    env_file: .env
    environment:
      # Aponta para o novo banco de dados central, mas para a DB específica
      - AUTH_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-db:5432/${AUTH_DB_NAME}
    depends_on:
      postgres-db: { condition: service_healthy }
    volumes:
      - ./services/auth-service:/app
    networks:
      - crm_network

  # --- SERVIÇO DE CLIENTES ---
  customer-service:
    build:
      context: ./services/customer-service
    container_name: customer_service
    restart: unless-stopped
    env_file: .env
    environment:
      # Aponta para o novo banco de dados central
      - CUSTOMER_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-db:5432/${CUSTOMER_DB_NAME}
    depends_on:
      postgres-db: { condition: service_healthy }
    volumes:
      - ./services/customer-service:/app
    networks:
      - crm_network
      

  # --- SERVIÇO DE PRODUTOS ---
  product-service:
    build:
      context: ./services/product-service
    container_name: product_service
    restart: unless-stopped
    env_file: .env
    environment:
      # Aponta para o novo banco de dados central
      - PRODUCT_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-db:5432/${PRODUCT_DB_NAME}
    depends_on:
      postgres-db: { condition: service_healthy }
    volumes:
      - ./services/product-service:/app
    networks:
      - crm_network

  # --- SERVIÇO DE INTERAÇÕES ---
  interaction-service:
    build:
      context: ./services/interaction-service
    container_name: interaction_service
    restart: unless-stopped
    env_file: .env
    environment:
      # Aponta para o novo banco de dados central
      - INTERACTION_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres-db:5432/${INTERACTION_DB_NAME}
      - CUSTOMER_SERVICE_URL=http://customer-service:5000
    depends_on:
      postgres-db: { condition: service_healthy }
      customer-service: { condition: service_started }
    volumes:
      - ./services/interaction-service:/app
    networks:
      - crm_network

  # --- BANCO DE DADOS CENTRAL (ÚNICO) ---
  postgres-db:
    image: postgres:16 # Usando a imagem completa
    container_name: postgres_db
    restart: unless-stopped
    env_file: .env # Carrega POSTGRES_USER, POSTGRES_PASSWORD, etc.
    ports:
      - "5432:5432" # Expõe a porta padrão do Postgres
    volumes:
      # Monta o script de inicialização para ser executado na primeira vez
      - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
      # Volume persistente para todos os dados do banco
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      # O healthcheck agora só precisa de verificar se o usuário 'postgres' pode conectar
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s # Período de tolerância para o arranque
    networks:
      - crm_network

# --- Volumes Persistentes (Agora só um) ---
volumes:
  postgres_data:

# --- Rede Compartilhada ---
networks:
  crm_network:
    driver: bridge